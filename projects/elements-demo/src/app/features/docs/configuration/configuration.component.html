<div class="wrapper">
  <h1>Configuration</h1>

  <blockquote class="large">
    The library supports additional configuration which can improve developer
    experience when using multiple elements (or same element multiple time).
  </blockquote>

  <h2>Pre-configuration with module</h2>
  <p>
    Let's imagine situation in which we want to use multiple instances of a
    single element in the template of one of our feature components.
  </p>
  <blockquote>
    Example of such an use case could be that we have a
    <code>&#60;user-profile-element></code>
    and we want to display top 3 users for a given month. We would need to pass
    url in all of the elements...
  </blockquote>

  <demo-example-code [example]="codeExampleInline" />

  <p>
    This could be optimized by storing url once in the component variable but
    still, component needs to be aware of the element url. This can lead to
    further inconvenient situation when element url changes and we would have to
    search for the url in te whole code base...
  </p>

  <p>
    Compare this to the following solution where we pre-configure all of the
    elements we will be using in our application with the help of the
    <code>LazyElementsModule.forRoot(options)</code>
    (or
    <code>.forFeature()</code>
    ) static functions!
  </p>

  <demo-example-code
    [example]="codeExampleStandalone"
    [exampleModule]="codeExampleModule"
  />

  <p>
    We're creating options of the
    <code>LazyElementModuleOptions</code>
    type and passing in array of
    <code>ElementConfig</code>
    items. Every item specifies element
    <code>tag</code>
    and
    <code>url</code>
    ...
  </p>

  <p>
    With this configuration in place, we can adjust original
    <code>FeatureComponent</code>
    template to look like this...
  </p>

  <demo-example-code [example]="codeExamplePreConfigured" />

  <p>
    As we can see, the component template got simple! There is less redundant
    data and the configuration was centralized in the predictable place that is
    easy to find and adjust when necessary!
  </p>

  <p>
    Check out the
    <a routerLink="/examples/advanced">working demo</a>
    of this approach!
  </p>

  <h2>Supported features</h2>
  <ul>
    <li>
      ✅ Global and granular configuration of
      <code>isModule</code>
      flag (script type module for ECMAScript modules)
    </li>
    <li>
      ✅ Global and granular configuration of
      <code>loadingComponent</code>
      (and
      <code>loadingTemplate</code>
      )
    </li>
    <li>
      ✅ Global and granular configuration of
      <code>errorComponent</code>
      (and
      <code>errorTemplate</code>
      )
    </li>
    <li>✅ Granular element pre-loading (config based)</li>
    <li>
      ✅ Ability to pre-load elements based on custom conditions using a service
    </li>
  </ul>
</div>
